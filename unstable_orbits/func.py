from numba import njit, cfunc, prange
import numpy as np
from orbits import crtbp_ode

jkw = dict(cache=True)


@njit(**jkw)
def rk7_step(f, t, s: np.ndarray, h, But: np.ndarray, b: np.ndarray, c: np.ndarray, mc: np.ndarray):
    '''
    –§—É–Ω–∫—Ü–∏—è rk7_step –≤—ã–ø–æ–ª–Ω—è–µ—Ç –æ–¥–∏–Ω —à–∞–≥ —Ä–∞–∑–º–µ—Ä–∞ h –º–µ—Ç–æ–¥–∞ –†—É–Ω–≥–µ-–ö—É—Ç—Ç—ã 5-–≥–æ –ø–æ—Ä—è–¥–∫–∞ –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ç–∞–±–ª–∏—Ü—ã –ë—É—Ç—á–µ—Ä–∞

    :param f: func
            —Ñ—É–Ω–∫—Ü–∏—è, –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è—é—â–∞—è –ø—Ä–∞–≤—É—é —á–∞—Å—Ç—å –°–û–î–£ (–¥–∏—Ñ—Ñ–µ—Ä–µ–Ω—Ü–∏–∞–ª—å–Ω–æ–µ —É—Ä–∞–≤–Ω–µ–Ω–∏–µ)
    :param t: float
            —Ç–µ–∫—É—â–µ–µ –≤—Ä–µ–º—è
    :param s: np.ndarray
            —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ —Å–∏—Å—Ç–µ–º—ã (–≤–µ–∫—Ç–æ—Ä –∑–Ω–∞—á–µ–Ω–∏–π –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö)
    :param h: float
            —à–∞–≥ –∏–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞–Ω–∏—è
    :param But, b, c: np.ndarray, np.ndarray, np.ndarray
            —Ç–∞–±–ª–∏—Ü–∞ –ë—É—Ç—á–µ—Ä–∞, –æ–ø—Ä–µ–¥–µ–ª—è—é—â–∞—è –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç—ã –º–µ—Ç–æ–¥–∞ –†—É–Ω–≥–µ-–ö—É—Ç—Ç—ã
    :param mc: np.ndarray
            –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –º–æ–¥–µ–ª–∏

    :return: np.ndarray
            –∏–∑–º–µ–Ω–µ–Ω–Ω—ã–π –≤–µ–∫—Ç–æ—Ä s –ø–æ—Å–ª–µ –æ–¥–Ω–æ–≥–æ —à–∞–≥–∞ –∏–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞–Ω–∏—è
    '''
    sn = But.shape[0]

    k_arr = np.zeros((sn, len(s)), dtype=np.float64)
    k_arr[0] = f(t, s, mc)
    ki = np.empty_like(s)

    for i in range(1, sn):
        ki[...] = 0
        j = 0
        while j < i:
            ki += But[i,j] * k_arr[j] * h
            j += 1
        k_arr[i] = f(t + c[i]*h, s + ki, mc)

    b_end = np.zeros(len(s), dtype=np.float64)
    for i in range(sn):
        b_end += b[i]*k_arr[i]

    return s + h * b_end


@njit(**jkw)
def rk7_nsteps(f, t, s: np.ndarray, h, mc: np.ndarray, n, But: np.ndarray, b: np.ndarray, c: np.ndarray, pl: np.ndarray):
    '''
    –§—É–Ω–∫—Ü–∏—è rk7_nsteps –≤—ã–ø–æ–ª–Ω—è–µ—Ç –Ω–µ—Å–∫–æ–ª—å–∫–æ —à–∞–≥–æ–≤ —Ä–∞–∑–º–µ—Ä–∞ h –º–µ—Ç–æ–¥–∞ –†—É–Ω–≥–µ-–ö—É—Ç—Ç—ã 5-–≥–æ –ø–æ—Ä—è–¥–∫–∞

    :param f: func
            —Ñ—É–Ω–∫—Ü–∏—è, –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è—é—â–∞—è –ø—Ä–∞–≤—É—é —á–∞—Å—Ç—å —Å–∏—Å—Ç–µ–º—ã –¥–∏—Ñ—Ñ–µ—Ä–µ–Ω—Ü–∏–∞–ª—å–Ω—ã—Ö —É—Ä–∞–≤–Ω–µ–Ω–∏–π
    :param t: float
            —Ç–µ–∫—É—â–µ–µ –≤—Ä–µ–º—è
    :param s: np.ndarray
            —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ —Å–∏—Å—Ç–µ–º—ã (–≤–µ–∫—Ç–æ—Ä –∑–Ω–∞—á–µ–Ω–∏–π –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö)
    :param h: float
            —à–∞–≥ –∏–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞–Ω—è
    :param mc: np.ndarray
            –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –º–æ–¥–µ–ª–∏
    :param n: int
            –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —à–∞–≥–æ–≤
    :param But, b, c: np.ndarray, np.ndarray, np.ndarray
            —Ç–∞–±–ª–∏—Ü–∞ –ë—É—Ç—á–µ—Ä–∞, –æ–ø—Ä–µ–¥–µ–ª—è—é—â–∞—è –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç—ã –º–µ—Ç–æ–¥–∞ –†—É–Ω–≥–µ-–ö—É—Ç—Ç—ã
    :param pl: np.ndarray
            –≥—Ä–∞–Ω–∏—Ü—ã –∏–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞–Ω–∏—è

    :return: np.ndarray
            –º–∞—Å—Å–∏–≤, —Å–æ–¥–µ—Ä–∂–∞—â–∏–π —Å–æ—Å—Ç–æ—è–Ω–∏–µ —Å–∏—Å—Ç–µ–º—ã –≤ –∫–∞–∂–¥—ã–π –º–æ–º–µ–Ω—Ç –≤—Ä–µ–º–µ–Ω–∏, –ø–æ–∫–∞ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏–ª–æ –∏–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ
    '''
    arr = np.empty((n + 1, s.shape[0] + 1), dtype=np.float64)
    arr[:, 0] = t + h * np.arange(n + 1)
    arr[0, 1:] = s

    for i in range(n):
        arr[i + 1, 1:] = rk7_step(f,           # –ø—Ä–∞–≤–∞—è —á–∞—Å—Ç—å –°–û–î–£
                                  arr[i, 0],   # t_0
                                  arr[i, 1:],  # s_0
                                  h,           # —à–∞–≥ dt
                                  But,         # —Ç–∞–±–ª–∏—Ü–∞ –ë—É—Ç—á–µ—Ä–∞
                                  b,           # –≤–µ–∫—Ç–æ—Ä b
                                  c,           # –≤–µ–∫—Ç–æ—Ä c
                                  mc)          # –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –º–æ–¥–µ–ª–∏
        x = arr[i + 1, 1]
        if x < pl[0] or x > pl[1]:
            break
    return arr[:i + 2]


@njit(**jkw)
def get_plane(vy, f, s, h, mc, n, But, b, c, pl):
    '''
    –û–ø—Ä–µ–¥–µ–ª—è–µ—Ç, –≤—ã—à–µ–ª –ª–∏ —Å–ø—É—Ç–Ω–∏–∫ –∑–∞ –≥—Ä–∞–Ω–∏—Ü—ã –∏–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞–Ω–∏—è

    :param vy: float
            –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å —Å–ø—É—Ç–Ω–∏–∫–∞
    :param f: func
            —Ñ—É–Ω–∫—Ü–∏—è, –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è—é—â–∞—è –ø—Ä–∞–≤—É—é —á–∞—Å—Ç—å —Å–∏—Å—Ç–µ–º—ã –¥–∏—Ñ—Ñ–µ—Ä–µ–Ω—Ü–∏–∞–ª—å–Ω—ã—Ö —É—Ä–∞–≤–Ω–µ–Ω–∏–π
    :param s: np.ndarray
            —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ —Å–∏—Å—Ç–µ–º—ã (–≤–µ–∫—Ç–æ—Ä –∑–Ω–∞—á–µ–Ω–∏–π –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö)
    :param h: float
            —à–∞–≥ –∏–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞–Ω—è
    :param mc: np.ndarray
            –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –º–æ–¥–µ–ª–∏
    :param n: int
            –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —à–∞–≥–æ–≤
    :param But, b, c: np.ndarray, np.ndarray, np.ndarray
            —Ç–∞–±–ª–∏—Ü–∞ –ë—É—Ç—á–µ—Ä–∞, –æ–ø—Ä–µ–¥–µ–ª—è—é—â–∞—è –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç—ã –º–µ—Ç–æ–¥–∞ –†—É–Ω–≥–µ-–ö—É—Ç—Ç—ã
    :param pl: np.ndarray
            –≥—Ä–∞–Ω–∏—Ü—ã –∏–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞–Ω–∏—è

    :return: int
            -1, –µ—Å–ª–∏ —Å–ø—É—Ç–Ω–∏–∫ –≤–Ω–µ –æ—Ç—Ä–µ–∑–∫–∞, 1 - –µ—Å–ª–∏ –≤–Ω—É—Ç—Ä–∏
    '''
    s0 = s.copy()
    s0[4] = vy
    arr = rk7_nsteps(f, 0., s0, h, mc, n, But, b, c, pl)
    x = arr[-1, 1]
    xmean = np.mean(pl)
    return -1 if x < xmean else 1


@njit(**jkw)
def bisect_custom(func, a, b, *args):
    '''
    –†–µ–∞–ª–∏–∑–∞—Ü–∏—è –∞–ª–≥–æ—Ä–∏—Ç–º–∞ –±–∏—Å–µ–∫—Ü–∏–∏

    :param func: func
            –∏—Å—Å–ª–µ–¥—É–µ–º–∞—è —Ñ—É–Ω–∫—Ü–∏—è
    :param a: float
            –ª–µ–≤–∞—è –≥—Ä–∞–Ω–∏—Ü–∞
    :param b: float
            –ø—Ä–∞–≤–∞—è –≥—Ä–∞–Ω–∏—Ü–∞
    :param args: *args
            –∞—Ä–≥—É–º–µ–Ω—Ç—ã –¥–ª—è —Ñ—É–Ω–∫—Ü–∏–∏ func

    :return:
            —Ç–æ—á–∫–∞ —Ä–∞–∑—Ä—ã–≤–∞ —Ñ—É–Ω–∫—Ü–∏–∏, –ª–∏–±–æ np.nan, –µ—Å–ª–∏ –µ–µ –Ω–µ—Ç
    '''
    fa = func(a, *args)
    fb = func(b, *args)
    tol = 1e-16
    max_iter = 200

    if fa * fb >= 0:
        return np.nan

    for _ in range(max_iter):
        c = (a + b) / 2
        fc = func(c, *args)

        if abs(a - b) < tol:
            return c

        if fa * fc < 0:
            b = c
        else:
            a = c
            fa = fc

    return np.nan


@njit(**jkw)
def v0(f, s, h, mc, n, But, b, c, pl):
    '''
    –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Ä–∞—Å—á–µ—Ç–∞ –Ω–∞—á–∞–ª—å–Ω–æ–π —Å–∫–æ—Ä–æ—Å—Ç–∏ vy0 –Ω–∞ –æ—Å–Ω–æ–≤–µ –º–µ—Ç–æ–¥–∞ –±–∏—Å–µ–∫—Ü–∏–∏ –¥–ª—è –æ—Ä–±–∏—Ç—ã,
    –∑–∞–¥–∞–Ω–Ω–æ–π –Ω–∞—á–∞–ª—å–Ω—ã–º –ø–æ–ª–æ–∂–µ–Ω–∏–µ–º (x0,0,z0) –∏ —É—Å–ª–æ–≤–∏–µ–º –æ—Ä—Ç–æ–≥–æ–Ω–∞–ª—å–Ω–æ—Å—Ç–∏ –≤–µ–∫—Ç–æ—Ä–∞ —Å–∫–æ—Ä–æ—Å—Ç–∏ –∏ –ø–ª–æ—Å–∫–æ—Å—Ç–∏ ùëãùëÇùëç –≤ –Ω–∞—á–∞–ª—å–Ω—ã–π –º–æ–º–µ–Ω—Ç –≤—Ä–µ–º–µ–Ω–∏

    :param f: func
            —Ñ—É–Ω–∫—Ü–∏—è, –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è—é—â–∞—è –ø—Ä–∞–≤—É—é —á–∞—Å—Ç—å —Å–∏—Å—Ç–µ–º—ã –¥–∏—Ñ—Ñ–µ—Ä–µ–Ω—Ü–∏–∞–ª—å–Ω—ã—Ö —É—Ä–∞–≤–Ω–µ–Ω–∏–π
    :param s: np.ndarray
            —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ —Å–∏—Å—Ç–µ–º—ã (–≤–µ–∫—Ç–æ—Ä –∑–Ω–∞—á–µ–Ω–∏–π –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö)
    :param h: float
            —à–∞–≥ –∏–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞–Ω—è
    :param mc: np.ndarray
            –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –º–æ–¥–µ–ª–∏
    :param n: int
            –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —à–∞–≥–æ–≤
    :param But, b, c: np.ndarray, np.ndarray, np.ndarray
            —Ç–∞–±–ª–∏—Ü–∞ –ë—É—Ç—á–µ—Ä–∞, –æ–ø—Ä–µ–¥–µ–ª—è—é—â–∞—è –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç—ã –º–µ—Ç–æ–¥–∞ –†—É–Ω–≥–µ-–ö—É—Ç—Ç—ã
    :param pl: np.ndarray
            –≥—Ä–∞–Ω–∏—Ü—ã –∏–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞–Ω–∏—è

    :return: float
            –Ω–∞—á–∞–ª—å–Ω–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å vy0
    '''
    return bisect_custom(get_plane, -1.0, 1.0, f, s, h, mc, n, But, b, c, pl)
    #return bisect(get_plane, -1.0, 1.0, args=(f, s, h, mc, n, But, b, c, pl))


@njit(**jkw)
def jac(x, y, z, v, mc):
    '''
    –≤—ã—á–∏—Å–ª–µ–Ω–∏–µ –∫–æ–Ω—Å—Ç–∞–Ω—Ç—ã —è–∫–æ–±–∏

    :param x: float
            —Ö-–∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞
    :param y: float
            —É-–∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞
    :param z: float
            z-–∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞
    :param v: float
            —Å–∫–æ—Ä–æ—Å—Ç—å
    :param mc: np.ndarray
            –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –º–æ–¥–µ–ª–∏

    :return: float
            –∫–æ–Ω—Å—Ç–∞–Ω—Ç–∞ —è–∫–æ–±–∏
    '''
    mu2 = mc[0]
    mu1 = 1 - mu2

    r1 = ((x + mu2) ** 2 + y ** 2 + z ** 2) ** 0.5
    r2 = ((x - mu1) ** 2 + y ** 2 + z ** 2) ** 0.5
    return (x ** 2 + y ** 2) + 2 * (mu1 / r1) + 2 * (mu2 / r2) - v ** 2


@njit(parallel=True, **jkw)
def calculate(N, x_arr, z_arr, h, mc, n, But, b, c, pl):
    '''
    –∞–ª–≥–æ—Ä–∏—Ç–º –≤—ã—á–∏—Å–ª–µ–Ω–∏—è –Ω–∞—á–∞–ª—å–Ω—ã—Ö —Å–∫–æ—Ä–æ—Å—Ç–µ–π –æ—Ä–±–∏—Ç, –Ω–∞—á–∞–ª—å–Ω—ã–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è –∫–æ—Ç–æ—Ä—ã—Ö –∑–∞–¥–∞–Ω—ã –Ω–∞ —Ä–µ—à–µ—Ç–∫–µ

    :param N: int
            –∫–æ–ª-–≤–æ —É–∑–ª–æ–≤ –Ω–∞ —Ä–µ—à–µ—Ç–∫–µ –ø–æ –æ–¥–Ω–æ–π –æ—Å–∏
    :param x_arr: np.ndarray
            –≥—Ä–∞–Ω–∏—Ü—ã —Ä–µ—à–µ—Ç–∫–∏ –ø–æ –æ—Å–∏ —Ö
    :param z_arr: np.ndarray
            –≥—Ä–∞–Ω–∏—Ü—ã —Ä–µ—à–µ—Ç–∫–∏ –ø–æ –æ—Å–∏ z
    :param s: np.ndarray
            —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ —Å–∏—Å—Ç–µ–º—ã (–≤–µ–∫—Ç–æ—Ä –∑–Ω–∞—á–µ–Ω–∏–π –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö)
    :param h: float
            —à–∞–≥ –∏–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞–Ω—è
    :param mc: np.ndarray
            –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –º–æ–¥–µ–ª–∏
    :param n: int
            –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —à–∞–≥–æ–≤
    :param But, b, c: np.ndarray, np.ndarray, np.ndarray
            —Ç–∞–±–ª–∏—Ü–∞ –ë—É—Ç—á–µ—Ä–∞, –æ–ø—Ä–µ–¥–µ–ª—è—é—â–∞—è –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç—ã –º–µ—Ç–æ–¥–∞ –†—É–Ω–≥–µ-–ö—É—Ç—Ç—ã
    :param pl: np.ndarray
            –≥—Ä–∞–Ω–∏—Ü—ã –∏–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞–Ω–∏—è
    :return:
    '''
    J_c = np.zeros((N, N), dtype=np.float64)
    vv = np.zeros((N, N), dtype=np.float64)
    lat_x = np.linspace(x_arr[0], x_arr[1], N)
    lat_z = np.linspace(z_arr[0], z_arr[1], N)
    for i in prange(N):
        for j in range(N):
            s_n = np.zeros(6)
            s_n[0] = lat_x[i]
            s_n[2] = lat_z[j]
            v1 = v0(crtbp_ode, s_n, h, mc, n, But, b, c, pl)
            vv[i, j] = v1
            if v1 != np.nan:
                jacobian = jac(lat_x[i], 0., lat_z[j], v1, mc)
                J_c[i, j] = jacobian
    return J_c, vv